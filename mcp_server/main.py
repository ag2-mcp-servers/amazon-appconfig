# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:38:05+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import conint, constr

from models import (
    Application,
    Applications,
    ApplicationsApplicationIdConfigurationprofilesConfigurationProfileIdHostedconfigurationversionsContentTypePostRequest,
    ApplicationsApplicationIdConfigurationprofilesConfigurationProfileIdPatchRequest,
    ApplicationsApplicationIdConfigurationprofilesPostRequest,
    ApplicationsApplicationIdEnvironmentsEnvironmentIdDeploymentsPostRequest,
    ApplicationsApplicationIdEnvironmentsEnvironmentIdPatchRequest,
    ApplicationsApplicationIdEnvironmentsPostRequest,
    ApplicationsApplicationIdPatchRequest,
    ApplicationsPostRequest,
    BadRequestException,
    Configuration,
    ConfigurationProfile,
    ConfigurationProfiles,
    ConflictException,
    Deployment,
    Deployments,
    DeploymentStrategies,
    DeploymentstrategiesDeploymentStrategyIdPatchRequest,
    DeploymentstrategiesPostRequest,
    DeploymentStrategy,
    Environment,
    Environments,
    Extension,
    ExtensionAssociation,
    ExtensionAssociations,
    ExtensionassociationsExtensionAssociationIdPatchRequest,
    ExtensionassociationsPostRequest,
    Extensions,
    ExtensionsExtensionIdentifierPatchRequest,
    ExtensionsPostRequest,
    HostedConfigurationVersion,
    HostedConfigurationVersions,
    InternalServerException,
    PayloadTooLargeException,
    ResourceNotFoundException,
    ResourceTags,
    ServiceQuotaExceededException,
    TagKeys,
    TagsResourceArnPostRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<p>Use AppConfig, a capability of Amazon Web Services Systems Manager, to create, manage, and quickly deploy application configurations. AppConfig supports controlled deployments to applications of any size and includes built-in validation checks and monitoring. You can use AppConfig with applications hosted on Amazon EC2 instances, Lambda, containers, mobile applications, or IoT devices.</p> <p>To prevent errors when deploying application configurations, especially for production systems where a simple typo could cause an unexpected outage, AppConfig includes validators. A validator provides a syntactic or semantic check to ensure that the configuration you want to deploy works as intended. To validate your application configuration data, you provide a schema or an Amazon Web Services Lambda function that runs against the configuration. The configuration deployment or update can only proceed when the configuration data is valid.</p> <p>During a configuration deployment, AppConfig monitors the application to ensure that the deployment is successful. If the system encounters an error, AppConfig rolls back the change to minimize impact for your application users. You can configure a deployment strategy for each application or environment that includes deployment criteria, including velocity, bake time, and alarms to monitor. Similar to error monitoring, if a deployment triggers an alarm, AppConfig automatically rolls back to the previous version. </p> <p>AppConfig supports multiple use cases. Here are some examples:</p> <ul> <li> <p> <b>Feature flags</b>: Use AppConfig to turn on new features that require a timely deployment, such as a product launch or announcement. </p> </li> <li> <p> <b>Application tuning</b>: Use AppConfig to carefully introduce changes to your application that can only be tested with production traffic.</p> </li> <li> <p> <b>Allow list</b>: Use AppConfig to allow premium subscribers to access paid content. </p> </li> <li> <p> <b>Operational issues</b>: Use AppConfig to reduce stress on your application when a dependency or other external factor impacts the system.</p> </li> </ul> <p>This reference is intended to be used with the <a href="http://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html">AppConfig User Guide</a>.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Amazon AppConfig',
    version='2019-10-09',
    servers=[
        {
            'description': 'The AppConfig multi-region endpoint',
            'url': 'http://appconfig.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AppConfig multi-region endpoint',
            'url': 'https://appconfig.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AppConfig endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://appconfig.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AppConfig endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://appconfig.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/applications',
    description=""" Lists all applications in your Amazon Web Services account. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_applications(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications',
    description=""" Creates an application. In AppConfig, an application is simply an organizational construct like a folder. This organizational construct has a relationship with some unit of executable code. For example, you could create an application called MyMobileApp to organize and manage configuration data for a mobile application installed by your users. """,
    tags=[
        'application_crud_operations',
        'configuration_profile_crud_operations',
        'deployment_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_application(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{ApplicationId}',
    description=""" Deletes an application. Deleting an application does not delete a configuration from a host. """,
    tags=['application_crud_operations', 'configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_application(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}',
    description=""" Retrieves information about an application. """,
    tags=['configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_application(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/applications/{ApplicationId}',
    description=""" Updates an application. """,
    tags=['application_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_application(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/configurationprofiles',
    description=""" Lists the configuration profiles for an application. """,
    tags=['application_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_configuration_profiles(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    type: Optional[constr(pattern=r'^[a-zA-Z\.]+')] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications/{ApplicationId}/configurationprofiles',
    description=""" <p>Creates a configuration profile, which is information that enables AppConfig to access the configuration source. Valid configuration sources include the following:</p> <ul> <li> <p>Configuration data in YAML, JSON, and other formats stored in the AppConfig hosted configuration store</p> </li> <li> <p>Configuration data stored as objects in an Amazon Simple Storage Service (Amazon S3) bucket</p> </li> <li> <p>Pipelines stored in CodePipeline</p> </li> <li> <p>Secrets stored in Secrets Manager</p> </li> <li> <p>Standard and secure string parameters stored in Amazon Web Services Systems Manager Parameter Store</p> </li> <li> <p>Configuration data in SSM documents stored in the Systems Manager document store</p> </li> </ul> <p>A configuration profile includes the following information:</p> <ul> <li> <p>The URI location of the configuration data.</p> </li> <li> <p>The Identity and Access Management (IAM) role that provides access to the configuration data.</p> </li> <li> <p>A validator for the configuration data. Available validators include either a JSON Schema or an Amazon Web Services Lambda function.</p> </li> </ul> <p>For more information, see <a href="http://docs.aws.amazon.com/appconfig/latest/userguide/appconfig-creating-configuration-and-profile.html">Create a Configuration and a Configuration Profile</a> in the <i>AppConfig User Guide</i>.</p> """,
    tags=['application_crud_operations', 'configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_configuration_profile(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdConfigurationprofilesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}',
    description=""" Deletes a configuration profile. Deleting a configuration profile does not delete a configuration from a host. """,
    tags=['application_crud_operations', 'configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_configuration_profile(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}',
    description=""" Retrieves information about a configuration profile. """,
    tags=['configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_configuration_profile(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}',
    description=""" Updates a configuration profile. """,
    tags=['application_crud_operations', 'configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_configuration_profile(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdConfigurationprofilesConfigurationProfileIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}/hostedconfigurationversions',
    description=""" Lists configurations stored in the AppConfig hosted configuration store by version. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_hosted_configuration_versions(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    version_label: Optional[constr(min_length=1, max_length=64)] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}/hostedconfigurationversions#Content-Type',
    description=""" Creates a new configuration in the AppConfig hosted configuration store. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_hosted_configuration_version(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    description: Optional[constr(min_length=0, max_length=1024)] = Header(
        None, alias='Description'
    ),
    content__type: constr(min_length=1, max_length=255) = Header(
        ..., alias='Content-Type'
    ),
    latest__version__number: Optional[int] = Header(
        None, alias='Latest-Version-Number'
    ),
    version_label: Optional[
        constr(pattern=r'.*[^0-9].*', min_length=1, max_length=64)
    ] = Header(None, alias='VersionLabel'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdConfigurationprofilesConfigurationProfileIdHostedconfigurationversionsContentTypePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}/hostedconfigurationversions/{VersionNumber}',
    description=""" Deletes a version of a configuration from the AppConfig hosted configuration store. """,
    tags=[
        'hosted_configuration_version_crud_operations',
        'configuration_profile_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_hosted_configuration_version(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    version_number: int = Path(..., alias='VersionNumber'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}/hostedconfigurationversions/{VersionNumber}',
    description=""" Retrieves information about a specific configuration version. """,
    tags=[
        'hosted_configuration_version_crud_operations',
        'configuration_profile_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_hosted_configuration_version(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    version_number: int = Path(..., alias='VersionNumber'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications/{ApplicationId}/configurationprofiles/{ConfigurationProfileId}/validators#configuration_version',
    description=""" Uses the validators in a configuration profile to validate a configuration. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def validate_configuration(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    configuration_profile_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ConfigurationProfileId'
    ),
    configuration_version: constr(min_length=1, max_length=1024) = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/environments',
    description=""" Lists the environments for an application. """,
    tags=['application_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_environments(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications/{ApplicationId}/environments',
    description=""" Creates an environment. For each application, you define one or more environments. An environment is a deployment group of AppConfig targets, such as applications in a <code>Beta</code> or <code>Production</code> environment. You can also define environments for application subcomponents such as the <code>Web</code>, <code>Mobile</code> and <code>Back-end</code> components for your application. You can configure Amazon CloudWatch alarms for each environment. The system monitors alarms during a configuration deployment. If an alarm is triggered, the system rolls back the configuration. """,
    tags=['application_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_environment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdEnvironmentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{ApplicationId}/environments/{EnvironmentId}',
    description=""" Deletes an environment. Deleting an environment does not delete a configuration from a host. """,
    tags=['environment_crud_operations', 'configuration_profile_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_environment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/environments/{EnvironmentId}',
    description=""" Retrieves information about an environment. An environment is a deployment group of AppConfig applications, such as applications in a <code>Production</code> environment or in an <code>EU_Region</code> environment. Each configuration deployment targets an environment. You can enable one or more Amazon CloudWatch alarms for an environment. If an alarm is triggered during a deployment, AppConfig roles back the configuration. """,
    tags=['environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_environment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/applications/{ApplicationId}/environments/{EnvironmentId}',
    description=""" Updates an environment. """,
    tags=['application_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_environment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdEnvironmentsEnvironmentIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/environments/{EnvironmentId}/deployments',
    description=""" Lists the deployments for an environment in descending deployment number order. """,
    tags=['environment_crud_operations', 'application_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_deployments(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/applications/{ApplicationId}/environments/{EnvironmentId}/deployments',
    description=""" Starts a deployment. """,
    tags=['deployment_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_deployment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApplicationsApplicationIdEnvironmentsEnvironmentIdDeploymentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/applications/{ApplicationId}/environments/{EnvironmentId}/deployments/{DeploymentNumber}',
    description=""" Stops a deployment. This API action works only on deployments that have a status of <code>DEPLOYING</code>. This action moves the deployment to a status of <code>ROLLED_BACK</code>. """,
    tags=['deployment_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def stop_deployment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    deployment_number: int = Path(..., alias='DeploymentNumber'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{ApplicationId}/environments/{EnvironmentId}/deployments/{DeploymentNumber}',
    description=""" Retrieves information about a configuration deployment. """,
    tags=['deployment_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_deployment(
    application_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='ApplicationId'),
    environment_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(..., alias='EnvironmentId'),
    deployment_number: int = Path(..., alias='DeploymentNumber'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/applications/{Application}/environments/{Environment}/configurations/{Configuration}#client_id',
    description=""" <p>(Deprecated) Retrieves the latest deployed configuration.</p> <important> <p>Note the following important information.</p> <ul> <li> <p>This API action is deprecated. Calls to receive configuration data should use the <a href="https://docs.aws.amazon.com/appconfig/2019-10-09/APIReference/API_appconfigdata_StartConfigurationSession.html">StartConfigurationSession</a> and <a href="https://docs.aws.amazon.com/appconfig/2019-10-09/APIReference/API_appconfigdata_GetLatestConfiguration.html">GetLatestConfiguration</a> APIs instead. </p> </li> <li> <p> <code>GetConfiguration</code> is a priced call. For more information, see <a href="https://aws.amazon.com/systems-manager/pricing/">Pricing</a>.</p> </li> </ul> </important> """,
    tags=['configuration_profile_crud_operations', 'environment_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_configuration(
    application: constr(min_length=1, max_length=64) = Path(..., alias='Application'),
    environment: constr(min_length=1, max_length=64) = Path(..., alias='Environment'),
    configuration: constr(min_length=1, max_length=64) = Path(
        ..., alias='Configuration'
    ),
    client_id: constr(min_length=1, max_length=64) = ...,
    client_configuration_version: Optional[
        constr(min_length=1, max_length=1024)
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/deployementstrategies/{DeploymentStrategyId}',
    description=""" Deletes a deployment strategy. Deleting a deployment strategy does not delete a configuration from a host. """,
    tags=['deployment_strategy_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_deployment_strategy(
    deployment_strategy_id: constr(
        pattern=r'(^[a-z0-9]{4,7}$|^AppConfig\.[A-Za-z0-9]{9,40}$)'
    ) = Path(..., alias='DeploymentStrategyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/deploymentstrategies',
    description=""" Lists deployment strategies. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
        'deployment_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_deployment_strategies(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/deploymentstrategies',
    description=""" Creates a deployment strategy that defines important criteria for rolling out your configuration to the designated targets. A deployment strategy includes the overall duration required, a percentage of targets to receive the deployment during each interval, an algorithm that defines how percentage grows, and bake time. """,
    tags=['deployment_crud_operations', 'deployment_strategy_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_deployment_strategy(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeploymentstrategiesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/deploymentstrategies/{DeploymentStrategyId}',
    description=""" Retrieves information about a deployment strategy. A deployment strategy defines important criteria for rolling out your configuration to the designated targets. A deployment strategy includes the overall duration required, a percentage of targets to receive the deployment during each interval, an algorithm that defines how percentage grows, and bake time. """,
    tags=['deployment_strategy_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_deployment_strategy(
    deployment_strategy_id: constr(
        pattern=r'(^[a-z0-9]{4,7}$|^AppConfig\.[A-Za-z0-9]{9,40}$)'
    ) = Path(..., alias='DeploymentStrategyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/deploymentstrategies/{DeploymentStrategyId}',
    description=""" Updates a deployment strategy. """,
    tags=['deployment_strategy_crud_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_deployment_strategy(
    deployment_strategy_id: constr(
        pattern=r'(^[a-z0-9]{4,7}$|^AppConfig\.[A-Za-z0-9]{9,40}$)'
    ) = Path(..., alias='DeploymentStrategyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DeploymentstrategiesDeploymentStrategyIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/extensionassociations',
    description=""" Lists all AppConfig extension associations in the account. For more information about extensions and associations, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=['extension_association_management', 'extension_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_extension_associations(
    resource_identifier: Optional[
        constr(
            pattern=r'arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1})?:(\d{12})?:[a-zA-Z0-9-_/:.]+',
            min_length=20,
            max_length=2048,
        )
    ] = None,
    extension_identifier: Optional[constr(min_length=1, max_length=2048)] = None,
    extension_version_number: Optional[int] = None,
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/extensionassociations',
    description=""" When you create an extension or configure an Amazon Web Services authored extension, you associate the extension with an AppConfig application, environment, or configuration profile. For example, you can choose to run the <code>AppConfig deployment events to Amazon SNS</code> Amazon Web Services authored extension and receive notifications on an Amazon SNS topic anytime a configuration deployment is started for a specific application. Defining which extension to associate with an AppConfig resource is called an <i>extension association</i>. An extension association is a specified relationship between an extension and an AppConfig resource, such as an application or a configuration profile. For more information about extensions and associations, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=['extension_association_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_extension_association(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ExtensionassociationsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/extensionassociations/{ExtensionAssociationId}',
    description=""" Deletes an extension association. This action doesn't delete extensions defined in the association. """,
    tags=['extension_association_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_extension_association(
    extension_association_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ExtensionAssociationId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/extensionassociations/{ExtensionAssociationId}',
    description=""" Returns information about an AppConfig extension association. For more information about extensions and associations, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=['extension_association_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_extension_association(
    extension_association_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ExtensionAssociationId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/extensionassociations/{ExtensionAssociationId}',
    description=""" Updates an association. For more information about extensions and associations, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=['extension_association_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_extension_association(
    extension_association_id: constr(pattern=r'[a-z0-9]{4,7}') = Path(
        ..., alias='ExtensionAssociationId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ExtensionassociationsExtensionAssociationIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/extensions',
    description=""" Lists all custom and Amazon Web Services authored AppConfig extensions in the account. For more information about extensions, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=[
        'configuration_profile_crud_operations',
        'hosted_configuration_version_crud_operations',
        'application_crud_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_extensions(
    max_results: Union[
        Optional[conint(ge=1, le=50)], Optional[str], Optional[str], Optional[str]
    ] = None,
    next_token: Union[
        Optional[constr(min_length=1, max_length=2048)],
        Optional[str],
        Optional[str],
        Optional[str],
    ] = None,
    name: Optional[constr(min_length=1, max_length=64)] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/extensions',
    description=""" <p>Creates an AppConfig extension. An extension augments your ability to inject logic or behavior at different points during the AppConfig workflow of creating or deploying a configuration.</p> <p>You can create your own extensions or use the Amazon Web Services authored extensions provided by AppConfig. For most use cases, to create your own extension, you must create an Lambda function to perform any computation and processing defined in the extension. For more information about extensions, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>.</p> """,
    tags=['extension_association_management', 'extension_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_extension(
    latest__version__number: Optional[int] = Header(
        None, alias='Latest-Version-Number'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ExtensionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/extensions/{ExtensionIdentifier}',
    description=""" Deletes an AppConfig extension. You must delete all associations to an extension before you delete the extension. """,
    tags=['extension_lifecycle_management', 'extension_association_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_extension(
    extension_identifier: constr(min_length=1, max_length=2048) = Path(
        ..., alias='ExtensionIdentifier'
    ),
    version: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/extensions/{ExtensionIdentifier}',
    description=""" Returns information about an AppConfig extension. """,
    tags=['extension_association_management', 'extension_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_extension(
    extension_identifier: constr(min_length=1, max_length=2048) = Path(
        ..., alias='ExtensionIdentifier'
    ),
    version_number: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/extensions/{ExtensionIdentifier}',
    description=""" Updates an AppConfig extension. For more information about extensions, see <a href="https://docs.aws.amazon.com/appconfig/latest/userguide/working-with-appconfig-extensions.html">Working with AppConfig extensions</a> in the <i>AppConfig User Guide</i>. """,
    tags=['extension_association_management', 'extension_lifecycle_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_extension(
    extension_identifier: constr(min_length=1, max_length=2048) = Path(
        ..., alias='ExtensionIdentifier'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ExtensionsExtensionIdentifierPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{ResourceArn}',
    description=""" Retrieves the list of key-value tags assigned to the resource. """,
    tags=['extension_association_management', 'resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1})?:(\d{12})?:[a-zA-Z0-9-_/:.]+',
        min_length=20,
        max_length=2048,
    ) = Path(..., alias='ResourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{ResourceArn}',
    description=""" Assigns metadata to an AppConfig resource. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define. You can specify a maximum of 50 tags for a resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1})?:(\d{12})?:[a-zA-Z0-9-_/:.]+',
        min_length=20,
        max_length=2048,
    ) = Path(..., alias='ResourceArn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{ResourceArn}#tagKeys',
    description=""" Deletes a tag key and value from an AppConfig resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: constr(
        pattern=r'arn:(aws[a-zA-Z-]*)?:[a-z]+:([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1})?:(\d{12})?:[a-zA-Z0-9-_/:.]+',
        min_length=20,
        max_length=2048,
    ) = Path(..., alias='ResourceArn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
